package tictactoe.logic;

import tictactoe.field.Coord;
import tictactoe.field.PlayingField;

/**
 * все действия игры.
 */
public class Logic {

    int win = -1;
    /**
     * Признак того, что игра идет. Если = 0, то новые ходы делать нельзя.
     */
    int flagGame = 1;

    /**
     * Игровое поле
     */
    PlayingField field;

    // Весовая матрица для различных вариантов ходов.
    int[][] ves = {
            {3, 2, 3},
            {2, 1, 2},
            {3, 2, 3}
    };

    /**
     * Все возможные сочетания линий на игровом поле
     */
    int[][][] hod = {
            {{0, 0}, {1, 0}, {2, 0}},
            {{0, 1}, {1, 1}, {2, 1}},
            {{0, 2}, {1, 2}, {2, 2}},
            {{0, 0}, {0, 1}, {0, 2}},
            {{1, 0}, {1, 1}, {1, 2}},
            {{2, 0}, {2, 1}, {2, 2}},
            {{0, 0}, {1, 1}, {2, 2}},
            {{2, 0}, {1, 1}, {0, 2}}
    };

    public Logic() {
        this.field = new PlayingField();
    }



    /**
     * Метод анализирует игрового поле после каждого хода,
     * посрдестволм анализа игровых ситуаций
     * res - результат обработки игровых ситуаций. Если > 0, значит кто-то выиграл или ничья.
     * Если игра может быть продолжена ищем куда походил человек и запускаем анализ.
     * Если какая-то ситуация выигрышная, то рисуем эти ячейки закрашенными.
     * @param v
     */
    public void gameAnaliz(int v) {
        /**
         *  логика
         */
    }

    /**
     * Анализируем результат хода.
     * Возвращает номер победителя
     * или играем дальше (возвратит 0).
     * Ищем ход для нолика, который приведет к победе.
     * Ищем клетку, которая приведет к победе крестик.
     * Если нет очивидных ходов анализируем по весу ячейки.
     * Если ни одна ситуация выше на сработала - значит у нас ничья.
     * @return
     */
    int analize() {
        return 3;
    }


    /**
     * Расчет хода на основе весовых коэфицентов.
     * Метод возвращает кординату куда нужно походить
     * Проходим по всем ячейкам, если находим пустую, то анализируем ее вес по таблице
     * @return Возвращаем найденную ячейку с минимальным весом.
     */
    private Coord calcVes() {
        Coord cord = new Coord();
        return cord;
    }


    /**
     * Поиск хода, который приведет к выиграшу для игрока с номером element.
     * Возвращает кординату ячейки, куда нужно походить.
     * Примерная логика:
     * В методе проходим по всем выиграшным ситуациям
     * внутри выиграшной ситауции проходим по всем ячейкам
     * Получаем координаты ячейки из массива ходов
     * Если в ячейке находиться искомый элемент, то увеличиваем счетчик ходов
     * Если пусто, то запоминаем кординату этой ячейки.
     * Если мы нашли, что в строке 2-а элемента совподают и есть пустая ячейка
     * возвращаем координату пустой ячейки.
     * @param element
     * @return Если выиграшной ситуации не найдено, то возвращаем пустую кординату.
     */
    private Coord seachHod(int element) {
        return new Coord();
    }

    /**
     * Поиск победителя.
     * Ищем среди вариантов выиграшных ситуаций.
     * @return Возвращаем номер победителя.
     */
    private int seachWin() {
        return 0;
    }

}
